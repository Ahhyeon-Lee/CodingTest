### **문제 설명**

다음 규칙을 지키는 문자열을 올바른 괄호 문자열이라고 정의합니다.

- `()`, `[]`, `{}` 는 모두 올바른 괄호 문자열입니다.
- 만약 `A`가 올바른 괄호 문자열이라면, `(A)`, `[A]`, `{A}` 도 올바른 괄호 문자열입니다. 예를 들어, `[]` 가 올바른 괄호 문자열이므로, `([])` 도 올바른 괄호 문자열입니다.
- 만약 `A`, `B`가 올바른 괄호 문자열이라면, `AB` 도 올바른 괄호 문자열입니다. 예를 들어, `{}` 와 `([])` 가 올바른 괄호 문자열이므로, `{}([])` 도 올바른 괄호 문자열입니다.

대괄호, 중괄호, 그리고 소괄호로 이루어진 문자열 `s`가 매개변수로 주어집니다. 이 `s`를 왼쪽으로 x (*0 ≤ x < (`s`의 길이)*) 칸만큼 회전시켰을 때 `s`가 올바른 괄호 문자열이 되게 하는 x의 개수를 return 하도록 solution 함수를 완성해주세요.

---

### 제한사항

- s의 길이는 1 이상 1,000 이하입니다.

---

### 입출력 예

| s | result |
| --- | --- |
| "[](){}" | 3 |
| "}]()[{" | 2 |
| "[)(]" | 0 |
| "}}}" | 0 |

---

### 입출력 예 설명

**입출력 예 #1**

- 다음 표는 `"[](){}"` 를 회전시킨 모습을 나타낸 것입니다.

| x | s를 왼쪽으로 x칸만큼 회전 | 올바른 괄호 문자열? |
| --- | --- | --- |
| 0 | "[](){}" | O |
| 1 | "](){}[" | X |
| 2 | "(){}[]" | O |
| 3 | "){}[](" | X |
| 4 | "{}[]()" | O |
| 5 | "}[](){" | X |
- 올바른 괄호 문자열이 되는 x가 3개이므로, 3을 return 해야 합니다.

**입출력 예 #2**

- 다음 표는 `"}]()[{"` 를 회전시킨 모습을 나타낸 것입니다.

| x | s를 왼쪽으로 x칸만큼 회전 | 올바른 괄호 문자열? |
| --- | --- | --- |
| 0 | "}]()[{" | X |
| 1 | "]()[{}" | X |
| 2 | "()[{}]" | O |
| 3 | ")[{}](" | X |
| 4 | "[{}]()" | O |
| 5 | "{}]()[" | X |
- 올바른 괄호 문자열이 되는 x가 2개이므로, 2를 return 해야 합니다.

**입출력 예 #3**

- s를 어떻게 회전하더라도 올바른 괄호 문자열을 만들 수 없으므로, 0을 return 해야 합니다.

**입출력 예 #4**

- s를 어떻게 회전하더라도 올바른 괄호 문자열을 만들 수 없으므로, 0을 return 해야 합니다.

### 나의 풀이

```kotlin
fun solution(s: String): Int {
    val pairMap = mapOf(
        '}' to '{',
        ')' to '(',
        ']' to '['
    )
    var string = s
    var answer = 0
    for (i in s.indices) { // s 길이 범위 만큼 돌기
        val stack = Stack<Char>()
        string.forEach { // string의 각 값을 stack에 넣으면서 괄호 검사
            when(it) {
                '{', '(', '[' -> {
                    stack.add(it)
                }
                '}', ')', ']' -> {
                    if (stack.isEmpty()) {
                        stack.add(it)
                        return@forEach
                    }
                    if (stack.peek() == pairMap[it]) {
                        stack.pop()
                    } else {
                        stack.add(it)
                    }
                }
            }
        }
        if (stack.isEmpty()) {
            answer++
        }
        string = string.substring(1 until string.length) + string.first()
    }

    return answer
}
```

1. Stack의 후입선출 원리를 이용해 s의 길이만큼 회전한 각 string의 값을 앞에서 부터 차례로 Stack에 넣는다.
2. 제일 윗 값(`peek()` / 후입 선출 원리에 의해 가장 최신값)과 비교해 괄호식에 맞으면 그 짝을 pop 한다.
3. i를 한 번 돌았을때 Stack이 비어있으면 모든 괄호가 맞았다는 의미로 볼 수 있으므로 카운트를 추가해준다.
